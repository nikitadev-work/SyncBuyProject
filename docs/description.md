# SyncBuy (MVP)

## 1) Цель и ценность
- **Проблема:** совместные покупки ведутся в чатах → хаос со статусами, кто сколько должен, дедлайны теряются.
- **Ценность:** единый бот и API с задачами, платёжными намерениями и авто-статусами по вебхуку; прозрачные отчёты и история.

## 2) Пользователи
- **Инициатор:** создаёт покупку, распределяет задачи и платежи.
- **Участник:** подтверждает участие, оплачивает, видит статусы.

## 3) Объём работ
- Telegram Bot, Web/Mobile, API-сервис.
- Платёжный контур: `payment_intents`, вебхуки (HMAC), простой **ledger** (двухзаписный).
- Инфраструктура: Postgres, Redis, Kafka, RabbitMQ; fake-psp; базовые метрики (Prometheus), дашборд (Grafana), трейс (Jaeger).
- Отчёты: итог по покупке (JSON/CSV), базовый взаимозачёт.

## 4) Допущения
- fake-psp от ЮКасса как провайдер.

## 5) Стратегии расчёта долгов("calculation-service")

### 5.1 Простая стратегия (accruals) — реализуется сейчас
- Каждый расход (задача со стоимостью) делится на всех участников.
- Каждому, кроме автора расхода, начисляется маленький долг автору.
- Долги по одному и тому же направлению `(payer → payee)` агрегируются.
- На выходе получается несколько прозрачных intents вида «Вася → Маша 250₽, Вася → Петя 50₽».
- **Плюсы:** очень понятно пользователям, легко объяснить «за что плачу».  
- **Минусы:** при большом числе участников и расходов долгов может быть много.

### 5.2 Альтернативная стратегия (балансы / netting) — может быть добавлена позже
- Считается общая сумма и справедливая доля на участника.
- Для каждого участника вычисляется баланс = расходы − доля.
- Должники переводят кредиторам так, чтобы балансы обнулились.
- Алгоритм подбирает минимальное число переводов (≤ N−1).
- **Плюсы:** мало переводов, удобно платить.  
- **Минусы:** пользователю менее очевидно, откуда именно сумма.

### 5.3 Текущий выбор
- Для MVP реализуется **простая стратегия (accruals)**.  
- В будущем можно заменить или добавить второй алгоритм, не меняя API.

## 6) Аутентификация и регистрация (две кнопки)
**Цель — простая и предсказуемая логика под кнопки «Логин» и «Регистрация».**

- **JWT** — единый способ доступа к Public API.
- **Логин:** `POST /auth/token` с `grant_type=password` или `grant_type=external_identity`.
  - Для `external_identity` (например, Telegram) логика **только «войти»**:
    - если внешний ID найден в `user_identities` → выдаём токен соответствующего `user_id`;
    - если не найден → **ошибка** `EXT_IDENTITY_NOT_FOUND` (ничего не создаём).
- **Регистрация:** `POST /auth/register` принимает либо `name+password`, либо `{ provider, proof }` для внешней регистрации.
  - Для `external_identity` — **идемпотентная** «создать или вернуть существующего»:
    - если такой внешний ID уже привязан → выдаём токен существующего `user_id`;
    - если нет → создаём нового пользователя + привязку → выдаём токен.
- **/me** — профиль текущего пользователя (по `sub` в JWT).

> **Линковка нового способа входа** (например, добавить пароль к телеге) — **в планах**. На MVP публичных ручек для этого нет. Позже добавим:
> - либо отдельные эндпоинты `/me/identities` (GET/POST/DELETE),
> - либо «link-режим» через тот же `/auth/token` при наличии Bearer JWT.

## 7) Технические детали реализации:

1) **Rate-limit на входе (API Gateway)** — защита публичных ручек (особенно `/auth/*`) от бурстов/ботов.  
2) **Дедупликация вебхуков (Payments)** — одно и то же событие PSP обрабатываем только один раз.  
3) **Idempotence-Key для создающих POST** — повторный POST с тем же ключом возвращает тот же результат без дублей.


## 7) Термины
- **Payment Intent** — внутренняя запись об обязательстве «кто → кому → сколько» (долг). Живёт в БД, один долг может закрываться несколькими попытками оплаты.
- **Payment Attempt** — конкретная попытка оплаты (ссылка/QR у провайдера). Может быть несколько попыток на один Intent (просрочена/отменена → создаём новую).
- **Webhook** — HTTP-уведомление от провайдера о статусе попытки оплаты (succeeded/failed/partial/refund).
- **Identity** — связь `user_id` (внутренний UUID) с внешним идентификатором (`telegram_id`, email, phone, OAuth). Один пользователь может иметь несколько identities.
- **Auth Flows:**
  - `password` — классический логин/пароль (для веб/мобилы).
  - `external_identity` — для Telegram Bot, Telegram WebApp, email/phone OTP, OAuth (Google/Apple).  
    Работает по принципу "find-or-create user" и возвращает JWT без пароля.

## 8) Шаблоны сообщений бота
- **Карточка долга:** «К оплате: `{{amount}}` ₽ до `{{due_at}}`. [Оплатить]»  
- **Успех:** «Оплата `{{amount}}` ₽ подтверждена ✅»  
- **Частично:** «Получено `{{paid}}` ₽, остаток `{{remaining}}` ₽»  
- **Ошибка/отмена:** «Платёж не прошёл ❌. Повторить?»  
- **Просрочка:** «Срок оплаты истёк ⏰»  
- **Закрытие:** «Покупка закрыта. Отчёт: [CSV] [JSON]»
