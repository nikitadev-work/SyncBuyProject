# SyncBuy (MVP)

## 1) Цель и ценность
- **Проблема:** совместные покупки ведутся в чатах → хаос со статусами, кто сколько должен, дедлайны теряются.
- **Ценность:** единый бот и API с задачами, платёжными намерениями и авто-статусами по вебхуку; прозрачные отчёты и история.

## 2) Пользователи
- **Инициатор:** создаёт покупку, распределяет задачи и платежи.
- **Участник:** подтверждает участие, оплачивает, видит статусы.

## 3) Объём работ
- Telegram Bot, Web/Mobile, API-сервис.
- Платёжный контур: `payment_intents`, вебхуки (HMAC), простой **ledger** (двухзаписный).
- Инфраструктура: Postgres, Redis, Kafka, RabbitMQ; fake-psp; базовые метрики (Prometheus), дашборд (Grafana), трейс (Jaeger).
- Отчёты: итог по покупке (JSON/CSV), базовый взаимозачёт.

## 4) Допущения
- fake-psp от ЮКасса как провайдер.

## 5) Стратегии расчёта долгов("calculation-service")

### 5.1 Простая стратегия (accruals) — реализуется сейчас
- Каждый расход (задача со стоимостью) делится на всех участников.
- Каждому, кроме автора расхода, начисляется маленький долг автору.
- Долги по одному и тому же направлению `(payer → payee)` агрегируются.
- На выходе получается несколько прозрачных intents вида «Вася → Маша 250₽, Вася → Петя 50₽».
- **Плюсы:** очень понятно пользователям, легко объяснить «за что плачу».  
- **Минусы:** при большом числе участников и расходов долгов может быть много.

### 5.2 Альтернативная стратегия (балансы / netting) — может быть добавлена позже
- Считается общая сумма и справедливая доля на участника.
- Для каждого участника вычисляется баланс = расходы − доля.
- Должники переводят кредиторам так, чтобы балансы обнулились.
- Алгоритм подбирает минимальное число переводов (≤ N−1).
- **Плюсы:** мало переводов, удобно платить.  
- **Минусы:** пользователю менее очевидно, откуда именно сумма.

### 5.3 Текущий выбор
- Для MVP реализуется **простая стратегия (accruals)**.  
- В будущем можно заменить или добавить второй алгоритм, не меняя API.

## 6) Авторизация и регистрация
- **JWT** — единый способ доступа к Public API.
- **Эндпоинты:**
  - `/auth/register` — регистрация локальной учётки с паролем.
  - `/auth/token`:
    - `grant_type=password` — логин по паролю.
    - `grant_type=external_identity` — Telegram, WebApp, email/phone OTP, OAuth.  
      Работает в режиме «создать пользователя, если его ещё нет».
    - `grant_type=refresh_token` — обновление JWT.
- **Telegram Bot:** использует `external_identity` (автоматическая привязка `telegram_id`).  
- **Web:** использует `register` + `password` grant.

## 7) Термины
- **Payment Intent** — внутренняя запись об обязательстве «кто → кому → сколько» (долг). Живёт в БД, один долг может закрываться несколькими попытками оплаты.
- **Payment Attempt** — конкретная попытка оплаты (ссылка/QR у провайдера). Может быть несколько попыток на один Intent (просрочена/отменена → создаём новую).
- **Webhook** — HTTP-уведомление от провайдера о статусе попытки оплаты (succeeded/failed/partial/refund).
- **Identity** — связь `user_id` (внутренний UUID) с внешним идентификатором (`telegram_id`, email, phone, OAuth). Один пользователь может иметь несколько identities.
- **Auth Flows:**
  - `password` — классический логин/пароль (для веб/мобилы).
  - `external_identity` — для Telegram Bot, Telegram WebApp, email/phone OTP, OAuth (Google/Apple).  
    Работает по принципу "find-or-create user" и возвращает JWT без пароля.

## 8) Шаблоны сообщений бота
- **Карточка долга:** «К оплате: `{{amount}}` ₽ до `{{due_at}}`. [Оплатить]»  
- **Успех:** «Оплата `{{amount}}` ₽ подтверждена ✅»  
- **Частично:** «Получено `{{paid}}` ₽, остаток `{{remaining}}` ₽»  
- **Ошибка/отмена:** «Платёж не прошёл ❌. Повторить?»  
- **Просрочка:** «Срок оплаты истёк ⏰»  
- **Закрытие:** «Покупка закрыта. Отчёт: [CSV] [JSON]»
